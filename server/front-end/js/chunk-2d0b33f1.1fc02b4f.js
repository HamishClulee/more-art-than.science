(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0b33f1"],{"280e":function(e,n){e.exports='<h1 id="syntax-highlighting-tester">Syntax Highlighting Tester</h1>\n<h2 id="now-with-extra-sauces">Now with extra sauces</h2>\n<p><mark class="divider">~</mark></p>\n<p>Something something something</p>\n<pre><code class="language-javascript">&lt;template&gt;\n    &lt;a :href=&quot;aref&quot;&gt;\n        &lt;article class=&quot;card-container&quot; @click=&quot;pushtohref()&quot;&gt;\n            &lt;section class=&quot;image-container&quot; :style=&quot;{ backgroundImage: `url(${image})`}&quot;&gt;\n                &lt;!-- image contained --&gt;\n            &lt;/section&gt;\n            &lt;section class=&quot;content-container&quot;&gt;\n                &lt;h3&gt;{{ title }}&lt;/h3&gt;\n                &lt;h5&gt;{{ sub }}&lt;/h5&gt;\n                &lt;p&gt;{{ shorttext }}&lt;/p&gt;\n            &lt;/section&gt;\n        &lt;/article&gt;\n    &lt;/a&gt;\n\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n    name: &#39;featurecard&#39;,\n    props: {\n        image: String,\n        title: String,\n        sub: String,\n        text: Array,\n        aref: String,\n        noclick: Boolean,\n    },\n    computed: {\n        shorttext() {\n            return `${this.text[0]}${this.text[1]}`\n        }\n    },\n}\n&lt;/script&gt;\n\n&lt;style scoped lang=&quot;sass&quot;&gt;\n.card-container\n    margin: 10px\n    background: #fff\n    color: #616161\n    transition: box-shadow 135ms 0ms cubic-bezier(0.4, 0, 0.2, 1)\n    box-shadow: 0 1px 1px 0 rgba(66, 66, 66, 0.08), 0 1px 3px 1px rgba(66, 66, 66, 0.16)\n    transition: width 235ms 0ms cubic-bezier(0.4, 0, 0.2, 1)\n    border-radius: 3px\n    z-index: 1\n    width: 400px\n.image-container\n    border-bottom: 1px solid $font-very-light\n    background-repeat: no-repeat\n    background-position: inherit\n    background-size: cover\n    height: 250px\n.content-container\n    padding: 10px\n    min-height: 375px\n    p\n        font-size: 1em\n.button-container\n    border-top: 1px solid $font-very-light\n    .card-button\n        border: none\n.middle\n    border-left: 1px solid $font-very-light\n    border-right: 1px solid $font-very-light\n&lt;/style&gt;</code></pre>\n<pre><code class="language-javascript">/*\nSyntax highlighting with language autodetection.\nhttps://highlightjs.org/\n*/\n\nimport deepFreeze from &#39;./vendor/deep_freeze.js&#39;;\nimport Response from &#39;./lib/response.js&#39;;\nimport TokenTreeEmitter from &#39;./lib/token_tree.js&#39;;\nimport * as regex from &#39;./lib/regex.js&#39;;\nimport * as utils from &#39;./lib/utils.js&#39;;\nimport * as MODES from &#39;./lib/modes.js&#39;;\nimport { compileLanguage } from &#39;./lib/mode_compiler.js&#39;;\nimport * as packageJSON from &#39;../package.json&#39;;\nimport { VuePlugin } from &quot;./plugins/vue&quot;;\n\nconst escape = utils.escapeHTML;\nconst inherit = utils.inherit;\n\nconst { nodeStream, mergeStreams } = utils;\nconst NO_MATCH = Symbol(&quot;nomatch&quot;);\n\n/**\n * @param {any} hljs - object that is extended (legacy)\n * @returns {HLJSApi}\n */\nconst HLJS = function(hljs) {\n  // Convenience variables for build-in objects\n  /** @type {unknown[]} */\n  var ArrayProto = [];\n\n  // Global internal variables used within the highlight.js library.\n  /** @type {Record&lt;string, Language&gt;} */\n  var languages = Object.create(null);\n  /** @type {Record&lt;string, string&gt;} */\n  var aliases = Object.create(null);\n  /** @type {HLJSPlugin[]} */\n  var plugins = [];\n\n  // safe/production mode - swallows more errors, tries to keep running\n  // even if a single syntax or parse hits a fatal error\n  var SAFE_MODE = true;\n  var fixMarkupRe = /(^(&lt;[^&gt;]+&gt;|\\t|)+|\\n)/gm;\n  var LANGUAGE_NOT_FOUND = &quot;Could not find the language &#39;{}&#39;, did you forget to load/include a language module?&quot;;\n  /** @type {Language} */\n  const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: &#39;Plain text&#39;, contains: [] };\n\n  // Global options used when within external APIs. This is modified when\n  // calling the `hljs.configure` function.\n  /** @type HLJSOptions */\n  var options = {\n    noHighlightRe: /^(no-?highlight)$/i,\n    languageDetectRe: /\\blang(?:uage)?-([\\w-]+)\\b/i,\n    classPrefix: &#39;hljs-&#39;,\n    tabReplace: null,\n    useBR: false,\n    languages: null,\n    // beta configuration options, subject to change, welcome to discuss\n    // https://github.com/highlightjs/highlight.js/issues/1086\n    __emitter: TokenTreeEmitter\n  };\n\n  /* Utility functions */\n\n  /**\n   * Tests a language name to see if highlighting should be skipped\n   * @param {string} languageName\n   */\n  function shouldNotHighlight(languageName) {\n    return options.noHighlightRe.test(languageName);\n  }\n\n  /**\n   * @param {HighlightedHTMLElement} block - the HTML element to determine language for\n   */\n  function blockLanguage(block) {\n    var classes = block.className + &#39; &#39;;\n\n    classes += block.parentNode ? block.parentNode.className : &#39;&#39;;\n\n    // language-* takes precedence over non-prefixed class names.\n    const match = options.languageDetectRe.exec(classes);\n    if (match) {\n      var language = getLanguage(match[1]);\n      if (!language) {\n        console.warn(LANGUAGE_NOT_FOUND.replace(&quot;{}&quot;, match[1]));\n        console.warn(&quot;Falling back to no-highlight mode for this block.&quot;, block);\n      }\n      return language ? match[1] : &#39;no-highlight&#39;;\n    }\n\n    return classes\n      .split(/\\s+/)\n      .find((_class) =&gt; shouldNotHighlight(_class) || getLanguage(_class));\n  }\n\n  /**\n   * Core highlighting function.\n   *\n   * @param {string} languageName - the language to use for highlighting\n   * @param {string} code - the code to highlight\n   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   * @param {Mode} [continuation] - current continuation mode, if any\n   *\n   * @returns {HighlightResult} Result - an object that represents the result\n   * @property {string} language - the language name\n   * @property {number} relevance - the relevance score\n   * @property {string} value - the highlighted HTML code\n   * @property {string} code - the original raw code\n   * @property {Mode} top - top of the current mode stack\n   * @property {boolean} illegal - indicates whether any illegal matches were found\n  */\n  function highlight(languageName, code, ignoreIllegals, continuation) {\n    /** @type {{ code: string, language: string, result?: any }} */\n    var context = {\n      code,\n      language: languageName\n    };\n    // the plugin can change the desired language or the code to be highlighted\n    // just be changing the object it was passed\n    fire(&quot;before:highlight&quot;, context);\n\n    // a before plugin can usurp the result completely by providing it&#39;s own\n    // in which case we don&#39;t even need to call highlight\n    var result = context.result ?\n      context.result :\n      _highlight(context.language, context.code, ignoreIllegals, continuation);\n\n    result.code = context.code;\n    // the plugin can change anything in result to suite it\n    fire(&quot;after:highlight&quot;, result);\n\n    return result;\n  }\n\n  /**\n   * private highlight that&#39;s used internally and does not fire callbacks\n   *\n   * @param {string} languageName - the language to use for highlighting\n   * @param {string} code - the code to highlight\n   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   * @param {Mode} [continuation] - current continuation mode, if any\n  */\n  function _highlight(languageName, code, ignoreIllegals, continuation) {\n    var codeToHighlight = code;\n\n    /**\n     * Return keyword data if a match is a keyword\n     * @param {CompiledMode} mode - current mode\n     * @param {RegExpMatchArray} match - regexp match data\n     * @returns {KeywordData | false}\n     */\n    function keywordData(mode, match) {\n      var matchText = language.case_insensitive ? match[0].toLowerCase() : match[0];\n      return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) &amp;&amp; mode.keywords[matchText];\n    }\n\n    function processKeywords() {\n      if (!top.keywords) {\n        emitter.addText(mode_buffer);\n        return;\n      }\n\n      let last_index = 0;\n      top.keywordPatternRe.lastIndex = 0;\n      let match = top.keywordPatternRe.exec(mode_buffer);\n      let buf = &quot;&quot;;\n\n      while (match) {\n        buf += mode_buffer.substring(last_index, match.index);\n        const data = keywordData(top, match);\n        if (data) {\n          const [kind, keywordRelevance] = data;\n          emitter.addText(buf);\n          buf = &quot;&quot;;\n\n          relevance += keywordRelevance;\n          emitter.addKeyword(match[0], kind);\n        } else {\n          buf += match[0];\n        }\n        last_index = top.keywordPatternRe.lastIndex;\n        match = top.keywordPatternRe.exec(mode_buffer);\n      }\n      buf += mode_buffer.substr(last_index);\n      emitter.addText(buf);\n    }\n\n    function processSubLanguage() {\n      if (mode_buffer === &quot;&quot;) return;\n      /** @type HighlightResult */\n      var result = null;\n\n      if (typeof top.subLanguage === &#39;string&#39;) {\n        if (!languages[top.subLanguage]) {\n          emitter.addText(mode_buffer);\n          return;\n        }\n        result = _highlight(top.subLanguage, mode_buffer, true, continuations[top.subLanguage]);\n        continuations[top.subLanguage] = result.top;\n      } else {\n        result = highlightAuto(mode_buffer, top.subLanguage.length ? top.subLanguage : null);\n      }\n\n      // Counting embedded language score towards the host language may be disabled\n      // with zeroing the containing mode relevance. Use case in point is Markdown that\n      // allows XML everywhere and makes every XML snippet to have a much larger Markdown\n      // score.\n      if (top.relevance &gt; 0) {\n        relevance += result.relevance;\n      }\n      emitter.addSublanguage(result.emitter, result.language);\n    }\n\n    function processBuffer() {\n      if (top.subLanguage != null) {\n        processSubLanguage();\n      } else {\n        processKeywords();\n      }\n      mode_buffer = &#39;&#39;;\n    }\n\n    /**\n     * @param {Mode} mode - new mode to start\n     */\n    function startNewMode(mode) {\n      if (mode.className) {\n        emitter.openNode(mode.className);\n      }\n      top = Object.create(mode, { parent: { value: top } });\n      return top;\n    }\n\n    /**\n     * @param {CompiledMode } mode - the mode to potentially end\n     * @param {RegExpMatchArray} match - the latest match\n     * @param {string} matchPlusRemainder - match plus remainder of content\n     * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode\n     */\n    function endOfMode(mode, match, matchPlusRemainder) {\n      let matched = regex.startsWith(mode.endRe, matchPlusRemainder);\n\n      if (matched) {\n        if (mode[&quot;on:end&quot;]) {\n          const resp = new Response(mode);\n          mode[&quot;on:end&quot;](match, resp);\n          if (resp.ignore) matched = false;\n        }\n\n        if (matched) {\n          while (mode.endsParent &amp;&amp; mode.parent) {\n            mode = mode.parent;\n          }\n          return mode;\n        }\n      }\n      // even if on:end fires an `ignore` it&#39;s still possible\n      // that we might trigger the end node because of a parent mode\n      if (mode.endsWithParent) {\n        return endOfMode(mode.parent, match, matchPlusRemainder);\n      }\n    }\n\n    /**\n     * Handle matching but then ignoring a sequence of text\n     *\n     * @param {string} lexeme - string containing full match text\n     */\n    function doIgnore(lexeme) {\n      if (top.matcher.regexIndex === 0) {\n        // no more regexs to potentially match here, so we move the cursor forward one\n        // space\n        mode_buffer += lexeme[0];\n        return 1;\n      } else {\n        // no need to move the cursor, we still have additional regexes to try and\n        // match at this very spot\n        continueScanAtSamePosition = true;\n        return 0;\n      }\n    }\n\n    /**\n     * Handle the start of a new potential mode match\n     *\n     * @param {EnhancedMatch} match - the current match\n     * @returns {number} how far to advance the parse cursor\n     */\n    function doBeginMatch(match) {\n      var lexeme = match[0];\n      var new_mode = match.rule;\n\n      const resp = new Response(new_mode);\n      // first internal before callbacks, then the public ones\n      const beforeCallbacks = [new_mode.__beforeBegin, new_mode[&quot;on:begin&quot;]];\n      for (const cb of beforeCallbacks) {\n        if (!cb) continue;\n        cb(match, resp);\n        if (resp.ignore) return doIgnore(lexeme);\n      }\n\n      if (new_mode &amp;&amp; new_mode.endSameAsBegin) {\n        new_mode.endRe = regex.escape(lexeme);\n      }\n\n      if (new_mode.skip) {\n        mode_buffer += lexeme;\n      } else {\n        if (new_mode.excludeBegin) {\n          mode_buffer += lexeme;\n        }\n        processBuffer();\n        if (!new_mode.returnBegin &amp;&amp; !new_mode.excludeBegin) {\n          mode_buffer = lexeme;\n        }\n      }\n      startNewMode(new_mode);\n      // if (mode[&quot;after:begin&quot;]) {\n      //   let resp = new Response(mode);\n      //   mode[&quot;after:begin&quot;](match, resp);\n      // }\n      return new_mode.returnBegin ? 0 : lexeme.length;\n    }\n\n    /**\n     * Handle the potential end of mode\n     *\n     * @param {RegExpMatchArray} match - the current match\n     */\n    function doEndMatch(match) {\n      var lexeme = match[0];\n      var matchPlusRemainder = codeToHighlight.substr(match.index);\n\n      var end_mode = endOfMode(top, match, matchPlusRemainder);\n      if (!end_mode) { return NO_MATCH; }\n\n      var origin = top;\n      if (origin.skip) {\n        mode_buffer += lexeme;\n      } else {\n        if (!(origin.returnEnd || origin.excludeEnd)) {\n          mode_buffer += lexeme;\n        }\n        processBuffer();\n        if (origin.excludeEnd) {\n          mode_buffer = lexeme;\n        }\n      }\n      do {\n        if (top.className) {\n          emitter.closeNode();\n        }\n        if (!top.skip &amp;&amp; !top.subLanguage) {\n          relevance += top.relevance;\n        }\n        top = top.parent;\n      } while (top !== end_mode.parent);\n      if (end_mode.starts) {\n        if (end_mode.endSameAsBegin) {\n          end_mode.starts.endRe = end_mode.endRe;\n        }\n        startNewMode(end_mode.starts);\n      }\n      return origin.returnEnd ? 0 : lexeme.length;\n    }\n\n    function processContinuations() {\n      var list = [];\n      for (var current = top; current !== language; current = current.parent) {\n        if (current.className) {\n          list.unshift(current.className);\n        }\n      }\n      list.forEach(item =&gt; emitter.openNode(item));\n    }\n\n    /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */\n    var lastMatch = {};\n\n    /**\n     *  Process an individual match\n     *\n     * @param {string} textBeforeMatch - text preceeding the match (since the last match)\n     * @param {EnhancedMatch} [match] - the match itself\n     */\n    function processLexeme(textBeforeMatch, match) {\n      var lexeme = match &amp;&amp; match[0];\n\n      // add non-matched text to the current mode buffer\n      mode_buffer += textBeforeMatch;\n\n      if (lexeme == null) {\n        processBuffer();\n        return 0;\n      }\n\n      // we&#39;ve found a 0 width match and we&#39;re stuck, so we need to advance\n      // this happens when we have badly behaved rules that have optional matchers to the degree that\n      // sometimes they can end up matching nothing at all\n      // Ref: https://github.com/highlightjs/highlight.js/issues/2140\n      if (lastMatch.type === &quot;begin&quot; &amp;&amp; match.type === &quot;end&quot; &amp;&amp; lastMatch.index === match.index &amp;&amp; lexeme === &quot;&quot;) {\n        // spit the &quot;skipped&quot; character that our regex choked on back into the output sequence\n        mode_buffer += codeToHighlight.slice(match.index, match.index + 1);\n        if (!SAFE_MODE) {\n          /** @type {AnnotatedError} */\n          const err = new Error(&#39;0 width match regex&#39;);\n          err.languageName = languageName;\n          err.badRule = lastMatch.rule;\n          throw err;\n        }\n        return 1;\n      }\n      lastMatch = match;\n\n      if (match.type === &quot;begin&quot;) {\n        return doBeginMatch(match);\n      } else if (match.type === &quot;illegal&quot; &amp;&amp; !ignoreIllegals) {\n        // illegal match, we do not continue processing\n        /** @type {AnnotatedError} */\n        const err = new Error(&#39;Illegal lexeme &quot;&#39; + lexeme + &#39;&quot; for mode &quot;&#39; + (top.className || &#39;&lt;unnamed&gt;&#39;) + &#39;&quot;&#39;);\n        err.mode = top;\n        throw err;\n      } else if (match.type === &quot;end&quot;) {\n        var processed = doEndMatch(match);\n        if (processed !== NO_MATCH) {\n          return processed;\n        }\n      }\n\n      // edge case for when illegal matches $ (end of line) which is technically\n      // a 0 width match but not a begin/end match so it&#39;s not caught by the\n      // first handler (when ignoreIllegals is true)\n      if (match.type === &quot;illegal&quot; &amp;&amp; lexeme === &quot;&quot;) {\n        // advance so we aren&#39;t stuck in an infinite loop\n        return 1;\n      }\n\n      // infinite loops are BAD, this is a last ditch catch all. if we have a\n      // decent number of iterations yet our index (cursor position in our\n      // parsing) still 3x behind our index then something is very wrong\n      // so we bail\n      if (iterations &gt; 100000 &amp;&amp; iterations &gt; match.index * 3) {\n        const err = new Error(&#39;potential infinite loop, way more iterations than matches&#39;);\n        throw err;\n      }\n\n      /*\n      Why might be find ourselves here?  Only one occasion now.  An end match that was\n      triggered but could not be completed.  When might this happen?  When an `endSameasBegin`\n      rule sets the end rule to a specific match.  Since the overall mode termination rule that&#39;s\n      being used to scan the text isn&#39;t recompiled that means that any match that LOOKS like\n      the end (but is not, because it is not an exact match to the beginning) will\n      end up here.  A definite end match, but when `doEndMatch` tries to &quot;reapply&quot;\n      the end rule and fails to match, we wind up here, and just silently ignore the end.\n      This causes no real harm other than stopping a few times too many.\n      */\n\n      mode_buffer += lexeme;\n      return lexeme.length;\n    }\n\n    var language = getLanguage(languageName);\n    if (!language) {\n      console.error(LANGUAGE_NOT_FOUND.replace(&quot;{}&quot;, languageName));\n      throw new Error(&#39;Unknown language: &quot;&#39; + languageName + &#39;&quot;&#39;);\n    }\n\n    var md = compileLanguage(language);\n    var result = &#39;&#39;;\n    /** @type {CompiledMode} */\n    var top = continuation || md;\n    /** @type Record&lt;string,Mode&gt; */\n    var continuations = {}; // keep continuations for sub-languages\n    var emitter = new options.__emitter(options);\n    processContinuations();\n    var mode_buffer = &#39;&#39;;\n    var relevance = 0;\n    var index = 0;\n    var iterations = 0;\n    var continueScanAtSamePosition = false;\n\n    try {\n      top.matcher.considerAll();\n\n      for (;;) {\n        iterations++;\n        if (continueScanAtSamePosition) {\n          // only regexes not matched previously will now be\n          // considered for a potential match\n          continueScanAtSamePosition = false;\n        } else {\n          top.matcher.lastIndex = index;\n          top.matcher.considerAll();\n        }\n        const match = top.matcher.exec(codeToHighlight);\n        // console.log(&quot;match&quot;, match[0], match.rule &amp;&amp; match.rule.begin)\n        if (!match) break;\n\n        const beforeMatch = codeToHighlight.substring(index, match.index);\n        const processedCount = processLexeme(beforeMatch, match);\n        index = match.index + processedCount;\n      }\n      processLexeme(codeToHighlight.substr(index));\n      emitter.closeAllNodes();\n      emitter.finalize();\n      result = emitter.toHTML();\n\n      return {\n        relevance: relevance,\n        value: result,\n        language: languageName,\n        illegal: false,\n        emitter: emitter,\n        top: top\n      };\n    } catch (err) {\n      if (err.message &amp;&amp; err.message.includes(&#39;Illegal&#39;)) {\n        return {\n          illegal: true,\n          illegalBy: {\n            msg: err.message,\n            context: codeToHighlight.slice(index - 100, index + 100),\n            mode: err.mode\n          },\n          sofar: result,\n          relevance: 0,\n          value: escape(codeToHighlight),\n          emitter: emitter\n        };\n      } else if (SAFE_MODE) {\n        return {\n          illegal: false,\n          relevance: 0,\n          value: escape(codeToHighlight),\n          emitter: emitter,\n          language: languageName,\n          top: top,\n          errorRaised: err\n        };\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * returns a valid highlight result, without actually doing any actual work,\n   * auto highlight starts with this and it&#39;s possible for small snippets that\n   * auto-detection may not find a better match\n   * @param {string} code\n   * @returns {HighlightResult}\n   */\n  function justTextHighlightResult(code) {\n    const result = {\n      relevance: 0,\n      emitter: new options.__emitter(options),\n      value: escape(code),\n      illegal: false,\n      top: PLAINTEXT_LANGUAGE\n    };\n    result.emitter.addText(code);\n    return result;\n  }\n\n  /**\n  Highlighting with language detection. Accepts a string with the code to\n  highlight. Returns an object with the following properties:\n  - language (detected language)\n  - relevance (int)\n  - value (an HTML string with highlighting markup)\n  - second_best (object with the same structure for second-best heuristically\n    detected language, may be absent)\n    @param {string} code\n    @param {Array&lt;string&gt;} [languageSubset]\n    @returns {AutoHighlightResult}\n  */\n  function highlightAuto(code, languageSubset) {\n    languageSubset = languageSubset || options.languages || Object.keys(languages);\n    var result = justTextHighlightResult(code);\n    var secondBest = result;\n    languageSubset.filter(getLanguage).filter(autoDetection).forEach(function(name) {\n      var current = _highlight(name, code, false);\n      current.language = name;\n      if (current.relevance &gt; secondBest.relevance) {\n        secondBest = current;\n      }\n      if (current.relevance &gt; result.relevance) {\n        secondBest = result;\n        result = current;\n      }\n    });\n    if (secondBest.language) {\n      // second_best (with underscore) is the expected API\n      result.second_best = secondBest;\n    }\n    return result;\n  }\n\n  /**\n  Post-processing of the highlighted markup:\n  - replace TABs with something more useful\n  - replace real line-breaks with &#39;&lt;br&gt;&#39; for non-pre containers\n    @param {string} html\n    @returns {string}\n  */\n  function fixMarkup(html) {\n    if (!(options.tabReplace || options.useBR)) {\n      return html;\n    }\n\n    return html.replace(fixMarkupRe, match =&gt; {\n      if (match === &#39;\\n&#39;) {\n        return options.useBR ? &#39;&lt;br&gt;&#39; : match;\n      } else if (options.tabReplace) {\n        return match.replace(/\\t/g, options.tabReplace);\n      }\n      return match;\n    });\n  }\n\n  /**\n   * Builds new class name for block given the language name\n   *\n   * @param {string} prevClassName\n   * @param {string} [currentLang]\n   * @param {string} [resultLang]\n   */\n  function buildClassName(prevClassName, currentLang, resultLang) {\n    var language = currentLang ? aliases[currentLang] : resultLang;\n    var result = [prevClassName.trim()];\n\n    if (!prevClassName.match(/\\bhljs\\b/)) {\n      result.push(&#39;hljs&#39;);\n    }\n\n    if (!prevClassName.includes(language)) {\n      result.push(language);\n    }\n\n    return result.join(&#39; &#39;).trim();\n  }\n\n  /**\n   * Applies highlighting to a DOM node containing code. Accepts a DOM node and\n   * two optional parameters for fixMarkup.\n   *\n   * @param {HighlightedHTMLElement} element - the HTML element to highlight\n  */\n  function highlightBlock(element) {\n    /** @type HTMLElement */\n    let node = null;\n    const language = blockLanguage(element);\n\n    if (shouldNotHighlight(language)) return;\n\n    fire(&quot;before:highlightBlock&quot;,\n      { block: element, language: language });\n\n    if (options.useBR) {\n      node = document.createElement(&#39;div&#39;);\n      node.innerHTML = element.innerHTML.replace(/\\n/g, &#39;&#39;).replace(/&lt;br[ /]*&gt;/g, &#39;\\n&#39;);\n    } else {\n      node = element;\n    }\n    const text = node.textContent;\n    const result = language ? highlight(language, text, true) : highlightAuto(text);\n\n    const originalStream = nodeStream(node);\n    if (originalStream.length) {\n      const resultNode = document.createElement(&#39;div&#39;);\n      resultNode.innerHTML = result.value;\n      result.value = mergeStreams(originalStream, nodeStream(resultNode), text);\n    }\n    result.value = fixMarkup(result.value);\n\n    fire(&quot;after:highlightBlock&quot;, { block: element, result: result });\n\n    element.innerHTML = result.value;\n    element.className = buildClassName(element.className, language, result.language);\n    element.result = {\n      language: result.language,\n      // TODO: remove with version 11.0\n      re: result.relevance,\n      relavance: result.relevance\n    };\n    if (result.second_best) {\n      element.second_best = {\n        language: result.second_best.language,\n        // TODO: remove with version 11.0\n        re: result.second_best.relevance,\n        relavance: result.second_best.relevance\n      };\n    }\n  }\n\n  /**\n   * Updates highlight.js global options with the passed options\n   *\n   * @param {{}} userOptions\n   */\n  function configure(userOptions) {\n    options = inherit(options, userOptions);\n  }\n\n  /**\n   * Highlights to all &lt;pre&gt;&lt;code&gt; blocks on a page\n   *\n   * @type {Function &amp; {called?: boolean}}\n   */\n  const initHighlighting = () =&gt; {\n    if (initHighlighting.called) return;\n    initHighlighting.called = true;\n\n    var blocks = document.querySelectorAll(&#39;pre code&#39;);\n    ArrayProto.forEach.call(blocks, highlightBlock);\n  };\n\n  // Higlights all when DOMContentLoaded fires\n  function initHighlightingOnLoad() {\n    // @ts-ignore\n    window.addEventListener(&#39;DOMContentLoaded&#39;, initHighlighting, false);\n  }\n\n  /**\n   * Register a language grammar module\n   *\n   * @param {string} languageName\n   * @param {LanguageFn} languageDefinition\n   */\n  function registerLanguage(languageName, languageDefinition) {\n    var lang = null;\n    try {\n      lang = languageDefinition(hljs);\n    } catch (error) {\n      console.error(&quot;Language definition for &#39;{}&#39; could not be registered.&quot;.replace(&quot;{}&quot;, languageName));\n      // hard or soft error\n      if (!SAFE_MODE) { throw error; } else { console.error(error); }\n      // languages that have serious errors are replaced with essentially a\n      // &quot;plaintext&quot; stand-in so that the code blocks will still get normal\n      // css classes applied to them - and one bad language won&#39;t break the\n      // entire highlighter\n      lang = PLAINTEXT_LANGUAGE;\n    }\n    // give it a temporary name if it doesn&#39;t have one in the meta-data\n    if (!lang.name) lang.name = languageName;\n    languages[languageName] = lang;\n    lang.rawDefinition = languageDefinition.bind(null, hljs);\n\n    if (lang.aliases) {\n      registerAliases(lang.aliases, { languageName });\n    }\n  }\n\n  /**\n   * @returns {string[]} List of language internal names\n   */\n  function listLanguages() {\n    return Object.keys(languages);\n  }\n\n  /**\n    intended usage: When one language truly requires another\n    Unlike `getLanguage`, this will throw when the requested language\n    is not available.\n    @param {string} name - name of the language to fetch/require\n    @returns {Language | never}\n  */\n  function requireLanguage(name) {\n    var lang = getLanguage(name);\n    if (lang) { return lang; }\n\n    var err = new Error(&#39;The \\&#39;{}\\&#39; language is required, but not loaded.&#39;.replace(&#39;{}&#39;, name));\n    throw err;\n  }\n\n  /**\n   * @param {string} name - name of the language to retrieve\n   * @returns {Language | undefined}\n   */\n  function getLanguage(name) {\n    name = (name || &#39;&#39;).toLowerCase();\n    return languages[name] || languages[aliases[name]];\n  }\n\n  /**\n   *\n   * @param {string|string[]} aliasList - single alias or list of aliases\n   * @param {{languageName: string}} opts\n   */\n  function registerAliases(aliasList, { languageName }) {\n    if (typeof aliasList === &#39;string&#39;) {\n      aliasList = [aliasList];\n    }\n    aliasList.forEach(alias =&gt; { aliases[alias] = languageName; });\n  }\n\n  /**\n   * Determines if a given language has auto-detection enabled\n   * @param {string} name - name of the language\n   */\n  function autoDetection(name) {\n    var lang = getLanguage(name);\n    return lang &amp;&amp; !lang.disableAutodetect;\n  }\n\n  /**\n   * @param {HLJSPlugin} plugin\n   */\n  function addPlugin(plugin) {\n    plugins.push(plugin);\n  }\n\n  /**\n   *\n   * @param {PluginEvent} event\n   * @param {any} args\n   */\n  function fire(event, args) {\n    var cb = event;\n    plugins.forEach(function(plugin) {\n      if (plugin[cb]) {\n        plugin[cb](args);\n      }\n    });\n  }\n\n  /* Interface definition */\n\n  Object.assign(hljs, {\n    highlight,\n    highlightAuto,\n    fixMarkup,\n    highlightBlock,\n    configure,\n    initHighlighting,\n    initHighlightingOnLoad,\n    registerLanguage,\n    listLanguages,\n    getLanguage,\n    registerAliases,\n    requireLanguage,\n    autoDetection,\n    inherit,\n    addPlugin,\n    // plugins for frameworks\n    vuePlugin: VuePlugin\n  });\n\n  hljs.debugMode = function() { SAFE_MODE = false; };\n  hljs.safeMode = function() { SAFE_MODE = true; };\n  hljs.versionString = packageJSON.version;\n\n  for (const key in MODES) {\n    // @ts-ignore\n    if (typeof MODES[key] === &quot;object&quot;) {\n      // @ts-ignore\n      deepFreeze(MODES[key]);\n    }\n  }\n\n  // merge all the modes/regexs into our main object\n  Object.assign(hljs, MODES);\n\n  return hljs;\n};\n\n// export an &quot;instance&quot; of the highlighter\nexport default HLJS({});</code></pre>\n'}}]);
//# sourceMappingURL=chunk-2d0b33f1.1fc02b4f.js.map